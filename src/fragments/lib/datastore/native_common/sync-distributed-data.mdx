## Distributed data

When working with distributed data, it is important to be mindful about the state of the local and the remote systems. DataStore tries to make that as simple as possible for you; however, some scenarios might require some consideration.


For instance, when updating or deleting data, one has to consider that the state of the local data might be out-of-sync with the backend. This scenario can affect how conditions should be implemented.

### Update and delete with predicate

For such scenarios both the `save()` and the `delete()` APIs support an optional predicate which will be sent to the backend and executed against the remote state.



import js43d3111d33961d21a5262c5334e5e8b973 from "/src/fragments/lib/datastore/js/sync/20-savePredicate.mdx";

<Fragments fragments={{js: js43d3111d33961d21a5262c5334e5e8b973}} />


import ios5fbda65afdc598251d6eb772396d28f7ac from "/src/fragments/lib/datastore/ios/sync/20-savePredicate.mdx";

<Fragments fragments={{ios: ios5fbda65afdc598251d6eb772396d28f7ac}} />


import android8243bfa4b526474c299129bee147c6b32f from "/src/fragments/lib/datastore/android/sync/20-savePredicate.mdx";

<Fragments fragments={{android: android8243bfa4b526474c299129bee147c6b32f}} />

There's a difference between the traditional local condition check using `if/else` constructs and the predicate in the aforementioned APIs as you can see in the example below.



import js82e91d443c26eb5c41060537b14685eb5a from "/src/fragments/lib/datastore/js/sync/30-savePredicateComparison.mdx";

<Fragments fragments={{js: js82e91d443c26eb5c41060537b14685eb5a}} />


import ios15df76c698b741a44a115599984108266e from "/src/fragments/lib/datastore/ios/sync/30-savePredicateComparison.mdx";

<Fragments fragments={{ios: ios15df76c698b741a44a115599984108266e}} />


import androidbf5046d48552817c3adc857418ba42ce65 from "/src/fragments/lib/datastore/android/sync/30-savePredicateComparison.mdx";

<Fragments fragments={{android: androidbf5046d48552817c3adc857418ba42ce65}} />

### Conflict detection and resolution

When concurrently updating the data in multiple places, it is likely that some conflict might happen. For most of the cases the default *Auto-merge* algorithm should be able to resolve conflicts. However, there are scenarios where the algorithm won't be able to be resolved, and in these cases, a more advanced option is available and will be described in detail in the next section.
